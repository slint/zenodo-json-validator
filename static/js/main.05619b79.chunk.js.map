{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["ajv","Ajv","schemaId","verbose","addMetaSchema","draft4","sample","title","creators","name","MyEditor","value","text","rest","this","jsonEditor","destroy","JSONEditor","htmlElementRef","onChange","handleChange","set","setText","JsonEditor","isObject","o","Editor","schema","metadata","allowedModes","ace","mode","onValidate","json","id","delta","diff","promises","license","push","Promise","resolve","reject","fetch","then","res","ok","catch","err","valid","path","message","grants","forEach","g","idx","grantUrl","test","validateGrant","communities","c","community_id","identifier","validateCommunity","all","errors","filter","error","App","useState","setSchema","setMetadata","useEffect","fetchSchema","a","data","properties","upload_type","enum","type","publication_type","image_type","e","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","console"],"mappings":"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","file":"static/js/main.05619b79.chunk.js","sourcesContent":["import React, { useEffect, useState, useCallback, useRef } from \"react\";\nimport Ajv from \"ajv\";\nimport { JsonEditor } from \"jsoneditor-react\";\nimport JSONEditor from \"jsoneditor/dist/jsoneditor-minimalist\";\nimport \"jsoneditor-react/es/editor.min.css\";\nimport ace from \"brace\";\nimport \"brace/mode/json\";\nimport \"brace/theme/github\";\nimport draft4 from \"ajv/lib/refs/json-schema-draft-04.json\";\nimport { diff } from \"jsondiffpatch\";\n\nconst schema_url =\n  \"https://sandbox.zenodo.org/api/schemas/deposits/records/legacyrecord.json\";\nconst ajv = new Ajv({ schemaId: \"id\", verbose: true });\najv.addMetaSchema(draft4);\n\n// TODO: Remove once JSONSchema \"enums\" are fixed in production\nfunction patchSchema(data) {\n  data.properties.upload_type.enum = data.properties.upload_type.type.enum;\n  data.properties.upload_type.type = \"string\";\n  data.properties.publication_type.enum =\n    data.properties.publication_type.type.enum;\n  data.properties.publication_type.type = \"string\";\n  data.properties.image_type.enum = data.properties.image_type.type.enum;\n  data.properties.image_type.type = \"string\";\n  return data;\n}\n\nconst validateLicense = (id) => {\n  return new Promise((resolve, reject) => {\n    fetch(`https://sandbox.zenodo.org/api/licenses/${id}`)\n      .then((res) => resolve(res.ok))\n      .catch((err) => reject(err));\n  });\n};\n\nconst validateGrant = (id) => {\n  return new Promise((resolve, reject) => {\n    var grantUrl = null;\n    if (/^\\d+$/.test(id)) {\n      grantUrl = `https://sandbox.zenodo.org/api/grants/10.13039/501100000780::${id}`;\n    } else {\n      grantUrl = `https://sandbox.zenodo.org/api/grants/${id}`;\n    }\n\n    fetch(grantUrl)\n      .then((res) => resolve(res.ok))\n      .catch((err) => reject(err));\n  });\n};\n\nconst validateCommunity = (id) => {\n  return new Promise((resolve, reject) => {\n    fetch(`https://sandbox.zenodo.org/api/communities/${id}`)\n      .then((res) => resolve(res.ok))\n      .catch((err) => reject(err));\n  });\n};\n\nconst sample = {\n  title: \"Software title v1\",\n  creators: [{ name: \"Alex\" }],\n};\n\nclass MyEditor extends JsonEditor {\n  createEditor({ value, text, ...rest }) {\n    if (this.jsonEditor) {\n      this.jsonEditor.destroy();\n    }\n\n    this.jsonEditor = new JSONEditor(this.htmlElementRef, {\n      onChange: this.handleChange,\n      ...rest,\n    });\n    if (value) {\n      this.jsonEditor.set(value);\n    } else if (text) {\n      this.jsonEditor.setText(text);\n    }\n  }\n}\n\nfunction isObject(o) {\n  return typeof o === \"object\" && o !== null;\n}\n\nfunction Editor({ schema, metadata, onChange }) {\n  const onValidate = (json) => {\n    var delta = diff(metadata, json);\n    var promises = [];\n    if (delta && delta.license) {\n      promises.push(\n        validateLicense(json.license).then((valid) => {\n          if (!valid) {\n            return {\n              path: [\"license\"],\n              message: `Invalid license ${json.license}.`,\n            };\n          } else {\n            return null;\n          }\n        })\n      );\n    }\n    if (delta && delta.grants) {\n      json.grants.forEach((g, idx) => {\n        if (g.id) {\n          promises.push(\n            validateGrant(g.id).then((valid) => {\n              if (!valid) {\n                return {\n                  path: [\"grants\", idx, \"id\"],\n                  message: `Invalid grant ID ${g.id}.`,\n                };\n              } else {\n                return null;\n              }\n            })\n          );\n        }\n      });\n    }\n    if (delta && delta.communities) {\n      json.communities.forEach((c, idx) => {\n        let community_id = c.identifier;\n        if (community_id) {\n          promises.push(\n            validateCommunity(community_id).then((valid) => {\n              if (!valid) {\n                return {\n                  path: [\"communities\", idx, \"identifier\"],\n                  message: `Invalid community ID ${community_id}.`,\n                };\n              } else {\n                return null;\n              }\n            })\n          );\n        }\n      });\n    }\n    return Promise.all(promises).then((errors) => {\n      return errors.filter((error) => {\n        return error != null;\n      });\n    });\n  };\n  return (\n    <>\n      <MyEditor\n        value={isObject(metadata) ? metadata : null}\n        text={!isObject(metadata) ? metadata : null}\n        onChange={onChange}\n        allowedModes={[\"tree\", \"code\", \"form\"]}\n        ajv={ajv}\n        schema={schema}\n        ace={ace}\n        mode={\"code\"}\n        onValidate={onValidate}\n      />\n    </>\n  );\n}\n\nfunction App() {\n  const [schema, setSchema] = useState(false);\n  const [metadata, setMetadata] = useState(null);\n\n  useEffect(() => {\n    const fetchSchema = async () => {\n      const res = await fetch(schema_url);\n      const json = await res.json();\n      setSchema(patchSchema(json));\n    };\n    setMetadata(sample);\n    fetchSchema();\n  }, []);\n\n  const onChange = (e) => {\n    // setMetadata(e);\n  };\n\n  return (\n    <>\n      {schema && metadata ? (\n        <Editor schema={schema} metadata={metadata} onChange={onChange} />\n      ) : (\n        <p>Loading schema...</p>\n      )}\n    </>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}